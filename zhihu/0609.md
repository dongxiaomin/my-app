## 一. 基础配置
* react: React 框架的核心

* react-dom: react 视图渲染的核心 (基于react构建app的html页面)

* react-scripts: 脚手架为了让项目目录看起来干净一些,把webpack打包的规则及相关插件, loader等都隐藏到node_modules目录下.

    react-scripts就是脚手架中自己对打包命令的一种封装.

* "web-vitals": 性能检测

* "test": "react-scripts test"单元测试

* browserslist: 浏览器兼容

* 后期webpack打包的时候,会对这个语法进行编译, 代表public目录
```
<link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
```


## 二. 其他配置
1. 暴露配置
**命令不可逆**
```
npm run eject
```

对 @babel/preset-env语法包的重写: (es6-> es5)
让语法包可以识别react语法, 实现代码重写.
```
babel-preset-react-app"
```

2. 默认安装为sass, 安装less
```
npm add less less-loader@8
npm remove sass sass-loader
```

3. 配置别名
alias: {
    '@': paths.appSrc,
}

4. 修改域名
`npm run start`默认域名为http://localhost/, 修改域名如下配置:
```zhihu/scripts/start.js
const HOST = process.env.HOST || '127.0.0.1';
```

5. 修改端口
`npm run start`默认端口为3000, 修改端口如下配置:
``` npm i cross-dev```
```package.json
"start": "cross-env PORT=8080 node scripts/start.js",
```

6.  对ES6 内置API做兼容处理, (有内置,不用单独配置)
```
import 'react-app-polyfill/ie11';
import 'react-app-polyfill/stable';
```

7. 处理跨域
7.1 ```npm install http-proxy-middleware```
http-proxy-middleware: 实现跨域代理的模块 [`webpack-dev-server` 的跨域代理原则,也是基于它完成的.]

7.2  新建 src/setupProxy.js
<!-- API test -->
jianshu.com/asimov/subscriptions/recommended_collections
news-at.zhihu.com/api/4/news/latest

```
const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = function (app) {
    app.use(
        createProxyMiddleware('/jian',{
            target: 'https://www.jianshu.com/asimov',
            changeOrigin: true,
            ws: true,
            pathRewrite: { '^/jian': '' }
        })
    );
    app.use(
        createProxyMiddleware('/zhi',{
            target: 'https://www.news-at.zhihu.com/api/4',
            changeOrigin: true,
            ws: true,
            pathRewrite: { '^/zhi': '' }
        })
    );
};
```

测试: index.js
```
fetch('/jian/subscriptions/recommended_collections')
  .then(response => response.json())
  .then(value => {
    console.log(value);
  })
fetch('/zhi/news/latest')
  .then(response => response.json())
  .then(value => {
    console.log(value);
  })
```

## 三. 体系
1. 数据驱动思想：
* 不会直接操作DOM
* 操作数据 「当我们修改了数据，框架会按照相关的数据，让页面重新渲染」
* 框架底层实现视图的渲染，也是基于操作DOM完成的
  构建了一套 虚拟DOM->真实DOM 的渲染体系
  有效避免了DOM的重排/重绘
  开发效率更高、最后的性能也相对较好

2. **React: MVC (module数据层 + view视图层 + controller控制层)**
* 我们需要按照专业的语法去构建视图（页面）：React中是基于jsx语法来构建视图的
* 构建数据层：但凡在视图中，需要”动态”处理的（需要变化的，不论是样式还是内容)，我们都要有对应的数据模型
* 控制层：当我们在视图中(或者根据业务需求）进行某些操作的时候，都是去修改相关的数据，然后React框架会按照最新的数据，重新渲染
视图，以此让用户看到最新的效果
数据驱动视图的渲染

3. 属性props处理

调用组件，传递进来的属性是“只读”的

获取：props.xxx

修改：props. xxx=xxx =>报错

原理: **props对象被冻结了**
```console.log(Object.isFrozen(props)); // true```

作用：父组件(index.jsx）调用子组件(DemoOne• jsx)的时候，可以基于属性，把不同的信息传递给子组件；子组件接收相应的属性值，呈现出不同的效果，让组件的复用性更强！！

虽然对于传递进来的厲性，我们不能直接修改，但是可以做一些规则校验

设置默认值
  函数组件
  defaultProps = {
   x: 0,
   ...
  }；

设置其他规则: 例数据格式 (prop-types)
  ```
  DemoOne.defaultProps = {
      x: 0
  };
  ```

传递进来的属性，首先会经历规则的校验， 不管校验成功还是失败，最后都会把属性给形参props，只不过如果不符合设定的规则，控制台会抛出
警告错误{不影响属性值的获取}！！


补充: 关于对象的三大规则设置:

3.1 **冻结**

  冻结对象：Object.freeze (obj)

  检测是否被冻结：Object.isFrozen(obj）=>true/false

  被冻结的对象：不能修改成员值、不能新增成员、不能删除现有成员、不能给成员做劫持 「Object. defineProperty」

  实例: 
  ```
  let obj ={ a: 1, b:2 };
  Object.freeze(obj);
  // {a: 1, b: 2}
  Object.isFrozen(obj)
  // true
  Object.defineProperty( obj, 'a', { get (){} }), 
  ```

3.2 **密封**

  密封对象：Object.seal(obj)

  检测是否被密封：Object.isSealed (obj)

  被密封的对象：可以修改成员的值，但也不能删、不能新增、不能劫持！！

  实例: 
  ```
    Object.seal(obj);
    console.log(Object.isSealed(obj))
  ```

3.3 **不可扩展**

  把对象设置为不可扩展：Object.preventExtensions(obj)

  检测是否可扩展：Object.isExtensible(obj)

  被设置不可扩展的对象：除了不能新增成员、其余的操作都可以处理！！

**被冻结的对象，即是密封的,也是不可扩展的; 同理，被密封的对象，也是不可扩展的！！**



4. 类型校验:
```
npm i prop-types
```

```
import PropTypes from 'prop-types';
...
DemoOne.propTypes = {
    x: PropTypes.number
}
```


## 三. 插槽处理
1. 默认插槽：通过组件标签体传入结构，固定写法

获取传递的属性和插槽信息
```
children = React.Children.toArray(children); 
```

2. 具名插槽: 给插槽起名字

目的：在调用组件，传递插槽信息的时候，我们可以不用考虑顺序直接设置好对应的名字即可！！！

```
<>
  <DemoOne title='我是标题1' x={1}>
    <div solt='footer'>2</div>
    <div solt='header'>1</div>
  </DemoOne>
</>
```

```
let { title, children } = props;
let headerSolt = [], footerSolt = [], defalutSolt = [];

children = React.Children.toArray(children); // console.log(React.Children.toArray(children));

children.forEach(child => {
    // 传递进来的插槽信息，都是编译为virtua1DOM后传递进来的「而不是传递的标签」
    let { solt } = child.props;
    if (solt == 'header') {
        headerSolt.push(child)
    } else if (solt == 'footer') {
        footerSolt.push(child)
    } else {
        defalutSolt.push(child)
    }
});
return (
    <div>
        {headerSolt}
        <div>{title}</div>
        {footerSolt}
    </div>
)
```


## 四. 静态组件和动态组件

1. 函数组件是“静态组件”

* 第一次渲染组件，把函数执行:
  产生一个私有的上下文：EC(V)   **execution context 执行上下文**

  把解析出来的props「含children」传递进来「但是被冻结了」

  対函数返回的JSX元素「virtualDOM」 逬行渲染

* 当我们点击按钮的时候，会把绑定的小函数执行：

  修改上级上下文EC(V)中的变量

  私有变量值发生了改变
 
  但是“视图不会更新”

=>也就是，函数组件第一次渲染完毕后，组件中的内容，不会根据组件内的某些操作，再进行更新，所以称它为静态组件
```
const Vote = function Vote(props) {
    let { title } = props;
    let supNum = 10,
        oppNum = 5;
    return <div className="vote-box">
        <div className="header">
            <h2 className="title">{title}</h2> <span>{supNum + oppNum}</span>
        </div>
        <div className="main" >
            <p> 支持人数：{supNum}</p>
            <p> 反对人数：{oppNum}</p>
        </div >

        <div className=" footer">
            <button onClick={() => {
                supNum++;
                console.log(supNum);
            }}> 支持</button >
            <button onClick={() => {
                oppNum++;
                console.log(oppNum);
            }}> 反对</button >
        </div >
    </div >;

};
export default Vote;
```


2. 创建类组件 ES5

基于es5 方式实现继承: 寄生组合式继承

```
function AAA() {
  React.Component.call(this); //call继承
  this.state = { x: 10, y: 20 };
} 
Object. setPrototype0f (AAA.prototype, React.Component.prototype); // 原型继承

AAA.prototype.sum = function () { };
```

真实项目中，有这样的需求：第一次渲染就不会再变化的，可以使用函数组件！！

但是大部分需求，都需要在第一次渲染完毕后，基于组件内部的某些操作，让组件可以更新，以此呈现出不同的效果！！==＞ 动态组件

「方法：类组件、Hooks组件(在函数组件中，使用Hooks函数)」


3. 创建类组件 ES6
* 创建一个构造函数(类)

  要求必须继承React.Component/Purecomponent这个类
  
  我们习惯于使用ES6中的class创建类「因为方便」
  
  必须给当前类设置一个render的方法「放在其原型上」：在render方法中，返回需要渲染的视图


## 五. 基于 extends 实现类的继承

* 首先基于call继承 React.Component.call(this) //this->Parent类的实例p
```
function Component (props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
```
给创建的实例p设置四个私有属性：props/context/refs/updater

* 再基于原型继承 `Parent.prototype._proto_ === React.Component.prototype`

实例 -＞ Parent.prototype -> React.Component.prototype -> object.prototype

实例除了具备`Parent.prototype`提供的方法之外，还具备了`React.Component.prototype`原型上提供的方法：`isReactcomponent、setstate、forceupdate`

* 只要自己设置了constructor，则内部第一句话一定要执行 super()

```
class Parent extends React.Component {
  constructor (n, m) {
    // this->p
    super()；//等价于 React.component.call(this)
  }
  x = 100;
  getX(){
    
  }
}

let p = new Parent (10, 20);
console.log (p);
```


## 六. 类组件第一次渲染底层逻辑
1. 先规则校验，校验完毕后，再处理属性的其他操作！！

方案一：
```
constructor(props ) {
  super(props); //会把传递进来的属性挂载到this实例上
  console.log(this.props); //获取到传递的属性
}
```

方案二：即便我们自己不在 `constructor` 中处理「或者`constructor`都没写」，在`constructor`处理完毕后，React内部也会把传递的props挂载到实例上；

所以在其他的函数中，只要保证this是实例，就可以基于this.props获取传递的属性！

同样this.props获取的属性对象也是被冻结的{只读的} Object. isFrozen(this.props)->true


2. 初始化状态

状态：后期修改状态，可以触发视图的更新

需要手动初始化，如果我们没有去做相关的处理，则默认会往实例上挂载一个state，初始值是null => this.state=nul1

手动处理：
```
state ={
  ...
};
```


3. 修改状态，控制视图更新

`this.state.xxx=xxx`：这种操作仅仅是修改了状态值，但是无法让视图更新

想让视图更新，我们需要基于React.Component.prototype提供的方法操作：

**@I** this.setstate(partialstate)既可以修改状态，也可以让视图更新 「推荐」
+ partialstate:部分状态
```
this.setState({
  XXX: XXX
});
```

**@2** `this.forceupdate()` 强制更新

```
class DemoTwo extends React.Component {
    // static defaultProps = {

    // };
    // static PropTypes = {

    // };
    state = {
        supNum: 20,
        oppNum: 10,
    };

    render (){
        let { title } = this.props,
            {supNum, oppNum} = this.state;
            return <div>
                <div>
                    <h2>{title}</h2>
                    <span>{supNum + oppNum}</span>
                </div>
                <div>
                    <p>支持人数: {supNum}</p>
                    <p>反对人数: {oppNum}</p>
                </div>
                <div>
                    <button onClick={() => {
                        this.setState({
                            supNum: supNum + 1
                        })
                    }}>支持</button>
                    <button onClick={() => {
                        this.state.oppNum ++;
                        this.forceUpdate();
                    }}>反对</button>
                </div>
            </div>
    }
}
```

4. 触发 `componentWillMount` 周期函数(钩子函数): 组件第一次渲染之前

在程序运行到某个阶段, 我们可以提供一个处理函数, 让开发者在这个阶段做一些自定义的事情.

```
UNSAFE_componentWillMount(){
    console.log('第一次渲染前')
}
```

注意:

`UNSAFE_componentWillMount`可以不让控制台抛出警告.

`React.StrictMode` 严格模式下使用 `UNSAFE_componentWillMount`, 控制台会报红色警告错误.

补充:
React. strictMode Vs "use strict"
* "use strict":Js的严格模式
* React.StrictMode： React的严格模式，它会去检查React中一些不规范的语法、或者是一些不建议使用的API等！！


5. 触发 `render`

6. 触发 `componentDidMound` 
已经把 `virtualDOM` 变为真实 DOM.


## 七. 总结:

1. 函数组件是“静态组件"：
  组件第一次渲染完毕后，无法基于“内部的某些操作”让组件更新「无法实现“自更新」；但是，如果调用它的父组件更新了，那么相关的子组件也一定会更新『可能传递最新的厲性值进来;

    函数组件具备：属性...

    优点: 比类组件处理的机制简单, 这样导致函数组件渲染速度更快.

2. 类组件是“动态组件"：

    组件在第一渲染完毕后，除了父组件更新可以触发其更新外，我们还可以通过：this.setstate修改状态 或者 this. forceupdate 等方式，让组件实现“自更新”！！

    类组件具备：属性、状态、周期西数、ref•••「几乎组件应该有的东西它都具备」

    优点: 功能强大

## 八. ref:

1. 基于ref获取DOM元素的语法

给需要获取的元素设置`ref=’xxx'`，后期基于`this.refs.xxx`去获取相应的DOM元素 **不推荐使用**

注意: 需要放在`componentDidMount`中执行

原因: 第一次渲染完毕 「virtualDOM已经变为真实DOM」：此时我们可以获取需要操作的DOM元素

```
render() {
      return <div>
          <h2 ref='titleBox'>{'test ref'}</h2>
      </div>
  }
  componentDidMount() {
      console.log('第一次渲染完毕')
      console.log(this.refs.titleBox)
  }
```

2. 把ref属性值设置为一个函数
`ref={x=>this.xxx=x}`

x是函数的形参：存储的就是当前DOM元素

然后我们获取的DOM元素“x”直接挂在到实例的某个属性上（例如：box2）

```
render() {
    return <div>
        <h2 ref='titleBox'>{'test ref'}</h2>
        <h2 ref={x => this.box2 = x}>友情提示</h2>
    </div>
}
componentDidMount() {
    console.log('第一次渲染完毕')
    console.log(this.box2)
}
```

3. 基于 React.createRef()方法创建一个ref 对象
`ref={ref对象}`

```
box3 = React.createRef();

render() {
    return <div>
          <h2 ref={this.box3}>友情提示</h2>
    </div>
}
componentDidMount() {
    console.log('第一次渲染完毕')
    console.log(this.box3.current)
}
```

## 九. setState进阶处理:

在React18中，`setstate` 操作都是异步的「不论是在哪执行，例如：合成事件、周期函数、定时器。…」

目的：实现状态的批处理「统一处理」

* 有效减少更新次数，降低性能消耗
* 有效管理代码执行的逻辑顺序

原理：利用了更新队列 `updater` 机制来处理的

* 在当前相同的时间段内 「浏览器此时可以处理的事情中」，遇到setstate会立即放入到更新队列中！
* 此时状态/视图还末更新
* 当所有的代码操作结束，会“刷新队列”「通知更新队列中的任务执行」：把所有放入的setstate合井在一起执行，只触发一次视圈更新「批处理操作」


## 十. `PureComponent`和`Component`的区别：

`Purecomponent`会给类组件**默认**加一个`shouldComponentupdate`周期函数

  在此周期函数中，它对新老的属性/状态 会做一个浅比较

  如果经过浅比较，发现属性和状态并没有改变，则返回false「也就是不继续更新组件」；有变化才会去更新！！
  
  如下示例, 内部属于浅比较: 
```
<!-- shouldComponentupdate(nextProps, nextState) {
  let { props, state } = this;
  return !shallowEqual(props, nextProps) || !shallowEqual(state, nextState);
} -->
```

 可以通过下面的方式 更新组件:
```
<button onClick={() => {
  this.setState({
    arr: [...arr]
  })
}}></button>
```

注意: **浅比较**

只比较对象的第一层, 如下: 

```
let obj = {
    z: 20
};

let objA = {
    x: 10,
    y: obj,
    arr: [10, 20, 30]
};

obj.n = 100;
let objB = {
    x: 10,
    y: obj,
    arr: [10, 20, 30]
};

//检测是否为对象
const isObject = (obj) => {
    return obj !== null && /^(object|function)$/.test(typeof obj);
};

const shallowEqual = () => {
    if (isObject(objA) || isObject(objB)) return false;
    if (objA === objB) return true;
    //先比较成员数量
    let keyA = Reflect.ownKeys(objA),
        keyB = Reflect.ownKeys(objB);
    if (keyA.length == keyB.length) return false;
    //数量一致, 再逐一比较内部成员 (浅比较: 只比第一级)
    for (let i = 0; i < keyA.length; i++) {
        let key = keyA[i];
        // 如果一个对象中有这个成员, 一个对象中没有; 戓者都有这个成员,但成员值不一样; 都应判定不相同.
        if (!objB.hasOwnProperty(key) || !Object.is(objA[key], objB[key])) {
            return false;;
        }
    }
    return true;
};

console.log(shallowEqual(objA, objB));
```

## 十一. 合成事件：

1. 基于React内部的处理，如果我们给合成事件绑定一个“普通函数〞，当事件行为触发，鄉定的函数执行；方法中的this会是 `undefined` 「不好」！！

解决方案：this->实例
* 我们可以基于JS中的bind方法：预先处理函数中的this和实参的
* 推荐：当然也可以把鄉定的函数设置为“箭头函数”，让其使用上下文中的this「也就是我们的实例」

```
handle1() { //DemoThree.prototype => DemoThree.prototype.handle1 = function handle1(){}
  console.log(this); //undefined 
};
handle2(x, y) {
  console.log(this, x, y); //实例,10,20
};
handle3 = () => {
  console.log(this); //实例
}
```

```
<button onClick={this.handle1}>handle1</button>
<button onClick={this.handle2.bind(this, 10, 20)}>handle2</button>
<button onClick={this.handle3}>handle3</button>
```


2. SyntheticBaseEvent:

合成事件对象 `SyntheticBaseEvent`：我们在`React`合成事件触发的时候，也可以获取到事件对象，只不过此对象是合成事件对象 

「React内部经过特殊处理，把各个浏览器的事件对象统一化后，构建的一个事件对象」

合成事件对象中，也包含了浏览器内置事件对象中的一些属性和方法「常用的基本都有」

+ clientX/clientY
+ pageX/pageY + target + type
+ preventDefault
+ stopPropagation
+ ...
+ nativeEvent：基于这个属性，可以获取浏览器内置 『原生』 的事件对象

3. `bind`在`React`事件绑定的中运用

+ 绑定的方法是一个普通西数，需要改变函数中的`this`为实例，此时需要用到`bind`「一般都是绑定箭头函数」
+ 想给函数传递指定的实参，可以基于`bind`预先处理「`bind`会把事件对象以最后一个实参传递给函数」


## 十二. 事件传播机制及事件委托

1. 事件传播机制

实例: 点击最内层元素

先捕获: 从 window --> document --> html --> body -->xxx --> 目标元素
再冒泡: 从 目标元素--> document --> ...--> window

`e.stopPropagation()`: 阻止事件(冒泡/捕获)传播
`e.stopImmediatePropagation()`: 也是阻止事件传播，只不过它可以把当前元素绑定的其他方法「同级的」，如果还未执行，也不会让其再执行！

2. 事件委托

只需要给容器做一个事件绑定「点击内部的任何元素，根据事件的冒泡传播机制，都会让容器的点击事件也触发」

利用事件的传播机制，实现的一套事件绑定处理方案

例如：一个容器中，有很多元素都要在点击的时候做一些事情

传统方案：首先获取需要操作的元素，然后逐一做事件绑定

事件委托：只需要给容器做一个事件绑定「点击内部的任何元素，根据事件的冒泡传播机制，都会让容器的点击事件也触发；我们在这里，根据事件源，做不同的事情就可以了；」

优势：
+ 提高了JS代码运行的性能，并且把处理的逻辑都集中在一起！！
+ 某些需求必须基于事件委托处理，例如：除了点击xxx外，点击其余元素需要有变化
+ 给动态绑定的元素做事件绑定

限制：
+ 当前操作的事件必须支持冒泡传播机制才可以
+ 例如：mouseenter/mouseleave等事件是没有冒泡传播机制的
+ 如果单独做的事件鄉定中，做了事件传播机制的阳止， 那么事件委托中的操作也不会生效！

3. 补充:

移动端click 存在 300ms 延迟

* 移动端: 单击事件 (点击后, 会监测300ms, 看是否有第二次操作; 如果没有就是单击, 如果有就是点击)
* PC端:  点击事件

* 使用`Fastclick`解决移动端使用click事件的300ms延迟问题*/
```
import Fastclick from "fastclick";
FastClick.attach(document.body);
```

## Task OA





