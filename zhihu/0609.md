## 一. 基础配置
* react: React 框架的核心

* react-dom: react 视图渲染的核心 (基于react构建app的html页面)

* react-scripts: 脚手架为了让项目目录看起来干净一些,把webpack打包的规则及相关插件, loader等都隐藏到node_modules目录下.

    react-scripts就是脚手架中自己对打包命令的一种封装.

* "web-vitals": 性能检测

* "test": "react-scripts test"单元测试

* browserslist: 浏览器兼容

* 后期webpack打包的时候,会对这个语法进行编译, 代表public目录
```
<link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
```


## 二. 其他配置
1. 暴露配置
**命令不可逆**
```
npm run eject
```

对 @babel/preset-env语法包的重写: (es6-> es5)
让语法包可以识别react语法, 实现代码重写.
```
babel-preset-react-app"
```

2. 默认安装为sass, 安装less
```
npm add less less-loader@8
npm remove sass sass-loader
```

3. 配置别名
alias: {
    '@': paths.appSrc,
}

4. 修改域名
`npm run start`默认域名为http://localhost/, 修改域名如下配置:
```zhihu/scripts/start.js
const HOST = process.env.HOST || '127.0.0.1';
```

5. 修改端口
`npm run start`默认端口为3000, 修改端口如下配置:
``` npm i cross-dev```
```package.json
"start": "cross-env PORT=8080 node scripts/start.js",
```

6.  对ES6 内置API做兼容处理, (有内置,不用单独配置)
```
import 'react-app-polyfill/ie11';
import 'react-app-polyfill/stable';
```

7. 处理跨域
7.1 ```npm install http-proxy-middleware```
http-proxy-middleware: 实现跨域代理的模块 [`webpack-dev-server` 的跨域代理原则,也是基于它完成的.]

7.2  新建 src/setupProxy.js
<!-- API test -->
jianshu.com/asimov/subscriptions/recommended_collections
news-at.zhihu.com/api/4/news/latest

```
const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = function (app) {
    app.use(
        createProxyMiddleware('/jian',{
            target: 'https://www.jianshu.com/asimov',
            changeOrigin: true,
            ws: true,
            pathRewrite: { '^/jian': '' }
        })
    );
    app.use(
        createProxyMiddleware('/zhi',{
            target: 'https://www.news-at.zhihu.com/api/4',
            changeOrigin: true,
            ws: true,
            pathRewrite: { '^/zhi': '' }
        })
    );
};
```

测试: index.js
```
fetch('/jian/subscriptions/recommended_collections')
  .then(response => response.json())
  .then(value => {
    console.log(value);
  })
fetch('/zhi/news/latest')
  .then(response => response.json())
  .then(value => {
    console.log(value);
  })
```

## 三. 体系
1. 数据驱动思想：
* 不会直接操作DOM
* 操作数据 「当我们修改了数据，框架会按照相关的数据，让页面重新渲染」
* 框架底层实现视图的渲染，也是基于操作DOM完成的
  构建了一套 虚拟DOM->真实DOM 的渲染体系
  有效避免了DOM的重排/重绘
  开发效率更高、最后的性能也相对较好

2. **React: MVC (module数据层 + view视图层 + controller控制层)**
* 我们需要按照专业的语法去构建视图（页面）：React中是基于jsx语法来构建视图的
* 构建数据层：但凡在视图中，需要”动态”处理的（需要变化的，不论是样式还是内容)，我们都要有对应的数据模型
* 控制层：当我们在视图中(或者根据业务需求）进行某些操作的时候，都是去修改相关的数据，然后React框架会按照最新的数据，重新渲染
视图，以此让用户看到最新的效果
数据驱动视图的渲染

3. 属性props处理

调用组件，传递进来的属性是“只读”的

获取：props.xxx

修改：props. xxx=xxx =>报错

原理: **props对象被冻结了**
```console.log(Object.isFrozen(props)); // true```

作用：父组件(index.jsx）调用子组件(DemoOne• jsx)的时候，可以基于属性，把不同的信息传递给子组件；子组件接收相应的属性值，呈现出不同的效果，让组件的复用性更强！！

虽然对于传递进来的厲性，我们不能直接修改，但是可以做一些规则校验

设置默认值
  函数组件
  defaultProps = {
   x: 0,
   ...
  }；

设置其他规则: 例数据格式 (prop-types)
  ```
  DemoOne.defaultProps = {
      x: 0
  };
  ```

传递进来的属性，首先会经历规则的校验， 不管校验成功还是失败，最后都会把属性给形参props，只不过如果不符合设定的规则，控制台会抛出
警告错误{不影响属性值的获取}！！


补充: 关于对象的三大规则设置:

3.1 **冻结**

  冻结对象：Object.freeze (obj)

  检测是否被冻结：Object.isFrozen(obj）=>true/false

  被冻结的对象：不能修改成员值、不能新增成员、不能删除现有成员、不能给成员做劫持 「Object. defineProperty」

  实例: 
  ```
  let obj ={ a: 1, b:2 };
  Object.freeze(obj);
  // {a: 1, b: 2}
  Object.isFrozen(obj)
  // true
  Object.defineProperty( obj, 'a', { get (){} }), 
  ```

3.2 **密封**

  密封对象：Object.seal(obj)

  检测是否被密封：Object.isSealed (obj)

  被密封的对象：可以修改成员的值，但也不能删、不能新增、不能劫持！！

  实例: 
  ```
    Object.seal(obj);
    console.log(Object.isSealed(obj))
  ```

3.3 **不可扩展**

  把对象设置为不可扩展：Object.preventExtensions(obj)

  检测是否可扩展：Object.isExtensible(obj)

  被设置不可扩展的对象：除了不能新增成员、其余的操作都可以处理！！

**被冻结的对象，即是密封的,也是不可扩展的; 同理，被密封的对象，也是不可扩展的！！**



4. 类型校验:
```
npm i prop-types
```

```
import PropTypes from 'prop-types';
...
DemoOne.propTypes = {
    x: PropTypes.number
}
```


## 三. 插槽处理
1. 默认插槽：通过组件标签体传入结构，固定写法

获取传递的属性和插槽信息
```
children = React.Children.toArray(children); 
```

2. 具名插槽: 给插槽起名字

目的：在调用组件，传递插槽信息的时候，我们可以不用考虑顺序直接设置好对应的名字即可！！！

```
<>
  <DemoOne title='我是标题1' x={1}>
    <div solt='footer'>2</div>
    <div solt='header'>1</div>
  </DemoOne>
</>
```

```
let { title, children } = props;
let headerSolt = [], footerSolt = [], defalutSolt = [];

children = React.Children.toArray(children); // console.log(React.Children.toArray(children));

children.forEach(child => {
    // 传递进来的插槽信息，都是编译为virtua1DOM后传递进来的「而不是传递的标签」
    let { solt } = child.props;
    if (solt == 'header') {
        headerSolt.push(child)
    } else if (solt == 'footer') {
        footerSolt.push(child)
    } else {
        defalutSolt.push(child)
    }
});
return (
    <div>
        {headerSolt}
        <div>{title}</div>
        {footerSolt}
    </div>
)
```


## 四. 静态组件和动态组件

1. 函数组件是“静态组件”

* 第一次渲染组件，把函数执行:
  产生一个私有的上下文：EC(V)   **execution context 执行上下文**

  把解析出来的props「含children」传递进来「但是被冻结了」

  対函数返回的JSX元素「virtualDOM」 逬行渲染

* 当我们点击按钮的时候，会把绑定的小函数执行：

  修改上级上下文EC(V)中的变量

  私有变量值发生了改变
 
  但是“视图不会更新”

=>也就是，函数组件第一次渲染完毕后，组件中的内容，不会根据组件内的某些操作，再进行更新，所以称它为静态组件
```
const Vote = function Vote(props) {
    let { title } = props;
    let supNum = 10,
        oppNum = 5;
    return <div className="vote-box">
        <div className="header">
            <h2 className="title">{title}</h2> <span>{supNum + oppNum}</span>
        </div>
        <div className="main" >
            <p> 支持人数：{supNum}</p>
            <p> 反对人数：{oppNum}</p>
        </div >

        <div className=" footer">
            <button onClick={() => {
                supNum++;
                console.log(supNum);
            }}> 支持</button >
            <button onClick={() => {
                oppNum++;
                console.log(oppNum);
            }}> 反对</button >
        </div >
    </div >;

};
export default Vote;
```


2. 创建类组件 ES5

基于es5 方式实现继承: 寄生组合式继承

```
function AAA() {
  React.Component.call(this); //call继承
  this.state = { x: 10, y: 20 };
} 
Object. setPrototype0f (AAA.prototype, React.Component.prototype); // 原型继承

AAA.prototype.sum = function () { };
```

真实项目中，有这样的需求：第一次渲染就不会再变化的，可以使用函数组件！！

但是大部分需求，都需要在第一次渲染完毕后，基于组件内部的某些操作，让组件可以更新，以此呈现出不同的效果！！==＞ 动态组件

「方法：类组件、Hooks组件(在函数组件中，使用Hooks函数)」


3. 创建类组件 ES6
* 创建一个构造函数(类)

  要求必须继承React.Component/Purecomponent这个类
  
  我们习惯于使用ES6中的class创建类「因为方便」
  
  必须给当前类设置一个render的方法「放在其原型上」：在render方法中，返回需要渲染的视图

4. 基于 extends 实现继承
* 首先基于call继承 React. Component . call(this) //this->Parent类的实例p
```
function Component (props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}
```
给创建的实例p设置四个私有属性：props/context/refs/updater

* 再基于原型继承 `Parent.prototype._proto_ === React. Component. prototype`

实例 -＞ Parent.prototype -> React.Component.prototype -> object.prototype

实例除了具备Parent.prototype提供的方法之外，还具备了React.Component.prototype原型上提供的方法：isReactcomponent、setstate、forceupdate

* 只要自己设置了constructor，则内部第一句话一定要执行 super()

```
class Parent extends React.Component {
  constructor (n, m) {
    // this->p
    super()；//等价于 React. CEmponent . call(this)
  }
  x = 100;
  getX(){
    
  }
}

let p = new Parent (10, 20);
console.log (p);
```

补充: js 数组知识
1. new Set是ES6新推出的一种类型, 去重最简单
```
const arr = [1,1,2,2,3,3,4,4,5,5];
const setData = Array.from(new Set(arr));
console.log(setData);
```

2. 使用filter配合indexOf进行去重
```
const handleRemoveRepeat = (arr) => arr.filter((item,index) => arr.indexOf(item,0) === index);
handleRemoveRepeat([1,2,2])
```

3. indexOf
```
const handleRemoveRepeat = (arr) => {
    let repeatArr = [];
    for (let i = 0,len = arr.length ; i < len; i++) 
     if (repeatArr.indexOf(arr[i]) === -1)  repeatArr.push(arr[i])
    return repeatArr;
}
handleRemoveRepeat([1,2,2,2,2])
```

4. includes (和 `indexOf` 很像)
```
const handleRemoveRepeat = (arr) => {
    let repeatArr = [];
    for (let i = 0,len = arr.length ; i < len; i++)
        if (!repeatArr.includes(arr[i])) repeatArr.push(arr[i])
    return repeatArr;
}
handleRemoveRepeat([1,2,2])
```

5. map() 方法用于对数组中的每个元素执行一个回调函数，并返回一个新的数组，新数组中的元素为回调函数的返回值。

```
const numbers = [1, 2, 3, 4, 5];
const squaredNumbers = numbers.map(num => num * num);
console.log(squaredNumbers); //[ 1, 4, 9, 16, 25 ]
```

6. filter() 方法用于筛选、过滤数组中符合条件的元素，并返回一个新的数组。
```
//筛选出偶数
const numbers = [1, 2, 3, 4, 5];
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); //[ 2, 4 ]
```

7. reduce() 方法是数组对象的一个方法，用于将数组中的所有元素按照指定的规则进行归并计算，返回一个最终值。
```
const arr = [1, 2, 3, 4, 5];
const sum = arr.reduce((acc, num) => {
  return acc + num
}, 10);
console.log(sum); //25
//如果初始值是设为0，则输出15
```