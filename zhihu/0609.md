## 一. 基础配置
* react: React 框架的核心

* react-dom: react 视图渲染的核心 (基于react构建app的html页面)

* react-scripts: 脚手架为了让项目目录看起来干净一些,把webpack打包的规则及相关插件, loader等都隐藏到node_modules目录下.

    react-scripts就是脚手架中自己对打包命令的一种封装.

* "web-vitals": 性能检测

* "test": "react-scripts test"单元测试

* browserslist: 浏览器兼容

* 后期webpack打包的时候,会对这个语法进行编译, 代表public目录
```
<link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
```


## 二. 其他配置
1. 暴露配置
**命令不可逆**
```
npm run eject
```

对 @babel/preset-env语法包的重写: (es6-> es5)
让语法包可以识别react语法, 实现代码重写.
```
babel-preset-react-app"
```

2. 默认安装为sass, 安装less
```
npm add less less-loader@8
npm remove sass sass-loader
```

3. 配置别名
alias: {
    '@': paths.appSrc,
}

4. 修改域名
`npm run start`默认域名为http://localhost/, 修改域名如下配置:
```zhihu/scripts/start.js
const HOST = process.env.HOST || '127.0.0.1';
```

5. 修改端口
`npm run start`默认端口为3000, 修改端口如下配置:
``` npm i cross-dev```
```package.json
"start": "cross-env PORT=8080 node scripts/start.js",
```

6.  对ES6 内置API做兼容处理, (有内置,不用单独配置)
```
import 'react-app-polyfill/ie11';
import 'react-app-polyfill/stable';
```

7. 处理跨域
7.1 ```npm install http-proxy-middleware```
http-proxy-middleware: 实现跨域代理的模块 [`webpack-dev-server` 的跨域代理原则,也是基于它完成的.]

7.2  新建 src/setupProxy.js
<!-- API test -->
jianshu.com/asimov/subscriptions/recommended_collections
news-at.zhihu.com/api/4/news/latest

```
const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = function (app) {
    app.use(
        createProxyMiddleware('/jian',{
            target: 'https://www.jianshu.com/asimov',
            changeOrigin: true,
            ws: true,
            pathRewrite: { '^/jian': '' }
        })
    );
    app.use(
        createProxyMiddleware('/zhi',{
            target: 'https://www.news-at.zhihu.com/api/4',
            changeOrigin: true,
            ws: true,
            pathRewrite: { '^/zhi': '' }
        })
    );
};
```

测试: index.js
```
fetch('/jian/subscriptions/recommended_collections')
  .then(response => response.json())
  .then(value => {
    console.log(value);
  })
fetch('/zhi/news/latest')
  .then(response => response.json())
  .then(value => {
    console.log(value);
  })
```

## 三. 体系
1. 数据驱动思想：
* 不会直接操作DOM
* 操作数据 「当我们修改了数据，框架会按照相关的数据，让页面重新渲染」
* 框架底层实现视图的渲染，也是基于操作DOM完成的
  构建了一套 虚拟DOM->真实DOM 的渲染体系
  有效避免了DOM的重排/重绘
  开发效率更高、最后的性能也相对较好

2. **React: MVC (module数据层 + view视图层 + controller控制层)**
* 我们需要按照专业的语法去构建视图（页面）：React中是基于jsx语法来构建视图的
* 构建数据层：但凡在视图中，需要”动态”处理的（需要变化的，不论是样式还是内容)，我们都要有对应的数据模型
* 控制层：当我们在视图中(或者根据业务需求）进行某些操作的时候，都是去修改相关的数据，然后React框架会按照最新的数据，重新渲染
视图，以此让用户看到最新的效果
数据驱动视图的渲染

3. 属性props处理

调用组件，传递进来的属性是“只读”的

获取：props.xxx

修改：props. xxx=xxx =>报错

原理: **props对象被冻结了**
```console.log(Object.isFrozen(props)); // true```

作用：父组件(index.jsx）调用子组件(DemoOne• jsx)的时候，可以基于属性，把不同的信息传递给子组件；子组件接收相应的属性值，呈现出不同的效果，让组件的复用性更强！！

虽然对于传递进来的厲性，我们不能直接修改，但是可以做一些规则校验

设置默认值
  函数组件
  defaultProps = {
   x: 0,
   ...
  }；

设置其他规则: 例数据格式 (prop-types)
  ```
  DemoOne.defaultProps = {
      x: 0
  };
  ```

传递进来的属性，首先会经历规则的校验， 不管校验成功还是失败，最后都会把属性给形参props，只不过如果不符合设定的规则，控制台会抛出
警告错误{不影响属性值的获取}！！


补充: 关于对象的三大规则设置:

3.1 **冻结**

  冻结对象：Object.freeze (obj)

  检测是否被冻结：Object.isFrozen(obj）=>true/false

  被冻结的对象：不能修改成员值、不能新增成员、不能删除现有成员、不能给成员做劫持 「Object. defineProperty」

  实例: 
  ```
  let obj ={ a: 1, b:2 };
  Object.freeze(obj);
  // {a: 1, b: 2}
  Object.isFrozen(obj)
  // true
  Object.defineProperty( obj, 'a', { get (){} }), 
  ```

3.2 **密封**

  密封对象：Object.seal(obj)

  检测是否被密封：Object.isSealed (obj)

  被密封的对象：可以修改成员的值，但也不能删、不能新增、不能劫持！！

  实例: 
  ```
    Object.seal(obj);
    console.log(Object.isSealed(obj))
  ```

3.3 **不可扩展**

  把对象设置为不可扩展：Object.preventExtensions(obj)

  检测是否可扩展：Object.isExtensible(obj)

  被设置不可扩展的对象：除了不能新增成员、其余的操作都可以处理！！

**被冻结的对象，即是密封的,也是不可扩展的; 同理，被密封的对象，也是不可扩展的！！**

